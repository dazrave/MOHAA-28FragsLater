// ============================================================================
// 28 Frags Later Mod - REFACTORED VERSION
// ============================================================================
// Original Author: Ophis
// Refactored: 2025
// Contact: ophis@daphi.co.uk
// Special thanks: Falco
//
// A zombie/infection survival mod for Medal of Honor: Allied Assault
// Transforms Team Deathmatch into an asymmetric horror experience
// ============================================================================

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

// Game mode constants
local.GAMEMODE_OFF = 0
local.GAMEMODE_OUTBREAK = 1      // Multiple survivors, infection spreads
local.GAMEMODE_INFECTION = 2     // Classic infection - one infected infects others
local.GAMEMODE_SURVIVAL = 3      // One survivor vs all infected

// Script configuration
local.SCRIPT_VERSION = "1.0.1"
local.REQUIRED_GAMETYPE = 2      // Team Deathmatch

// Logging configuration
// Set 28FL_LogLevel cvar to control logging detail:
//   0 = Off (no logging)
//   1 = Error (critical errors only)
//   2 = Info (default - important events)
//   3 = Debug (detailed debugging info)
//   4 = Verbose (all events including player actions)
local.LOGLEVEL_OFF = 0
local.LOGLEVEL_ERROR = 1
local.LOGLEVEL_INFO = 2
local.LOGLEVEL_DEBUG = 3
local.LOGLEVEL_VERBOSE = 4
local.DEFAULT_LOGLEVEL = 2       // Default to Info level

// Gameplay constants
local.SURVIVOR_TIME_LIMIT = 200  // Seconds survivor has to survive (LEGACY - not used with dynamic timing)
local.INFECTION_TIME_LIMIT = 300 // 5 minutes for infection mode
local.MIN_PLAYERS = 2            // Minimum players to start game
local.PROXIMITY_DISTANCE = 500   // Distance for proximity alerts (LEGACY - kept for compatibility)
local.TIMER_WARNING_YELLOW = 30  // Yellow warning at 30 seconds
local.TIMER_WARNING_RED = 10     // Red warning at 10 seconds

// Proximity message system (prevents camping)
local.PROXIMITY_TIMEOUT = 60     // Seconds before showing proximity hints (1 minute)
local.PROXIMITY_HOT = 10         // Distance in meters for "hot" indicator
local.PROXIMITY_WARM = 25        // Distance in meters for "warm" indicator
local.PROXIMITY_COLD = 50        // Distance in meters for "cold" indicator
local.PROXIMITY_NONE = 100       // Distance in meters - show nothing beyond this

// Dynamic Survival Time (Option 3 Scoring System)
local.DEFAULT_SURVIVAL_TIME = 300     // Default 5 minutes
local.TIME_REDUCTION_PERCENT = 5      // 5% reduction per infected player
local.MIN_SURVIVAL_TIME = 60          // Minimum 1 minute

// Team constants
local.TEAM_INFECTED = "axis"
local.TEAM_SURVIVOR = "allies"

// Model paths
local.MODEL_INFECTED = "models/player/german_[Kapo]_Prisioner_1.tik"
local.MODEL_SURVIVOR = "models/player/allied_Magna_Cartas_police.tik"

// Weapon paths
local.WEAPON_INFECTED = "models/weapons/colt45.tik"
local.WEAPON_SURVIVOR = "models/weapons/shotgun.tik"

// HUD constants
local.HUD_TIMER_ID = 107
local.HUD_TIMER_X = 500
local.HUD_TIMER_Y = 35

// Visual effects
local.FARPLANE_DISTANCE = 1600
local.FARPLANE_COLOR_NORMAL = "0 0 0"
local.FARPLANE_COLOR_LIGHTNING = "0.9 0.9 0.9"

// Update intervals (in seconds)
local.UPDATE_FASTSKY = 10
local.UPDATE_STORM_MIN = 30
local.UPDATE_STORM_VAR = 15

// Survivor selection constants
local.MAX_SURVIVOR_COUNT = 524288  // Maximum times someone can be survivor


// ============================================================================
// LOGGING SYSTEM
// ============================================================================

log local.level local.message:
    // Central logging function - respects log level configuration
    // Usage: thread log local.LOGLEVEL_INFO "Your message here"
    
    // Get configured log level (default to INFO if not set)
    local.configuredLevel = int(getcvar(28FL_LogLevel))
    if (local.configuredLevel == NIL || local.configuredLevel < 0) {
        local.configuredLevel = local.DEFAULT_LOGLEVEL
    }
    
    // Only log if message level is at or below configured level
    if (local.level > local.configuredLevel) {
        return
    }
    
    // Format log level prefix
    local.prefix = "[28FL] "
    switch (local.level) {
        case 1:
            local.prefix = "[28FL-ERROR] "
            break
        case 2:
            local.prefix = "[28FL-INFO] "
            break
        case 3:
            local.prefix = "[28FL-DEBUG] "
            break
        case 4:
            local.prefix = "[28FL-VERBOSE] "
            break
    }
    
    // Output to server console
    println local.prefix + local.message
    
    // Also write to game log file if g_log is enabled
    // logprint formats: "LogType: message\n"
    logprint local.prefix + local.message + "\n"
end

logError local.message:
    thread log local.LOGLEVEL_ERROR local.message
end

logInfo local.message:
    thread log local.LOGLEVEL_INFO local.message
end

logDebug local.message:
    thread log local.LOGLEVEL_DEBUG local.message
end

logVerbose local.message:
    thread log local.LOGLEVEL_VERBOSE local.message
end


// ============================================================================
// RCON COMMAND MONITORING
// ============================================================================

monitorRconCommands:
    // Monitor cvars for RCON commands
    // Server admins can use: set 28FL_Command "command_name"
    level.lastCommand = ""
    
    while (1) {
        local.command = getcvar(28FL_Command)
        
        if (local.command != NIL && local.command != "" && local.command != level.lastCommand) {
            level.lastCommand = local.command
            thread logInfo "RCON command received: " + local.command
            thread processRconCommand local.command
        }
        
        wait 1
    }
end

processRconCommand local.command:
    switch (local.command) {
        case "restart":
            thread logInfo "RCON: Restarting current game mode"
            iprintlnbold_noloc "Server admin restarting game..."
            // Reset game state based on mode
            if (level.gameMode == local.GAMEMODE_SURVIVAL) {
                level.survivor = NIL
                thread initSurvivalMode
            } else if (level.gameMode == local.GAMEMODE_OUTBREAK) {
                thread initOutbreakMode
            } else if (level.gameMode == local.GAMEMODE_INFECTION) {
                level.infectionActive = 0
                level.infectionRoundStarted = 0
                wait 1
                level.infectionActive = 1
                thread initInfectionMode
            }
            break
            
        case "status":
            thread logInfo "=== SERVER STATUS ==="
            thread logInfo "Game Mode: " + level.gameMode
            thread logInfo "Players: " + thread getPlayerCount
            thread logInfo "Script Version: " + level.scriptVersion
            if (level.gameMode == local.GAMEMODE_SURVIVAL && level.survivor != NIL) {
                thread logInfo "Current Survivor: " + level.survivor.netname
            }
            thread logInfo "===================="
            break
            
        case "listplayers":
            thread logInfo "=== PLAYER LIST ==="
            for (local.i = 1; local.i <= $player.size; local.i++) {
                if ($player[local.i].inGame) {
                    local.teamName = "spectator"
                    if ($player[local.i].dmteam == allies) {
                        local.teamName = "survivor"
                    } else if ($player[local.i].dmteam == axis) {
                        local.teamName = "infected"
                    }
                    thread logInfo "  " + $player[local.i].netname + " (" + local.teamName + ")"
                }
            }
            thread logInfo "===================="
            break
            
        case "nextround":
            thread logInfo "RCON: Forcing next round"
            iprintlnbold_noloc "Server admin forcing next round..."
            if (level.gameMode == local.GAMEMODE_SURVIVAL) {
                level.survivor = NIL
            } else if (level.gameMode == local.GAMEMODE_INFECTION) {
                level.infectionActive = 0
                level.infectionRoundStarted = 0
                wait 1
                level.infectionActive = 1
            }
            break
            
        default:
            thread logInfo "RCON: Unknown command: " + local.command
            break
    }
    
    // Clear the command cvar
    setcvar "28FL_Command" ""
end


// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

main:
    // Validate game mode
    if (int(getcvar(28FragsLater)) == local.GAMEMODE_OFF) {
        end
    }

    local.gameMode = int(getcvar(28FragsLater))
    
    // Initialize logging level
    local.configuredLevel = int(getcvar(28FL_LogLevel))
    if (local.configuredLevel == NIL || local.configuredLevel < 0) {
        setcvar "28FL_LogLevel" local.DEFAULT_LOGLEVEL
        local.configuredLevel = local.DEFAULT_LOGLEVEL
    }
    
    println "[28FL] Starting 28 Frags Later Mod v" + local.SCRIPT_VERSION
    println "[28FL] Game Mode: " + local.gameMode
    println "[28FL] Log Level: " + local.configuredLevel
    thread logInfo "==================================================================="
    thread logInfo "28 Frags Later Mod v" + local.SCRIPT_VERSION + " - Starting"
    thread logInfo "Game Mode: " + local.gameMode
    thread logInfo "Log Level: " + local.configuredLevel + " (0=Off,1=Error,2=Info,3=Debug,4=Verbose)"
    thread logInfo "==================================================================="

    // Prevent duplicate script execution
    if (level.isRunning) {
        thread logError "Script already running. Terminating."
        println "[28FL] ERROR: Script already running. Terminating."
        end
    }
    level.isRunning = 1

    // Validate Team Deathmatch is active
    if (int(getcvar(g_gametype)) != local.REQUIRED_GAMETYPE) {
        thread logError "Requires Team Deathmatch (g_gametype 2). Current: " + getcvar(g_gametype)
        println "[28FL] ERROR: Requires Team Deathmatch (g_gametype 2). Terminating."
        end
    }

    // Initialize level variables
    level.scriptVersion = local.SCRIPT_VERSION
    level.gameMode = local.gameMode
    level.survivorTimelimit = local.DEFAULT_SURVIVAL_TIME
    level.proximityTrigger = 0
    level.selectingSurvivor = 0
    level.survivor = NIL
    level.lastProximityTime = 0  // Track when players were last in proximity

    thread logInfo "Default survival time: " + level.survivorTimelimit + " seconds"
    println "[28FL] Default survival time: " + level.survivorTimelimit + " seconds"

    // Set game type display name
    setcvar "g_gametypestring" "28 Frags Later"

    // Start RCON command monitor
    thread monitorRconCommands
    thread logInfo "RCON command monitor started (use cvar 28FL_Command)"

    // Wait for game initialization
    level waittill prespawn
    thread logDebug "Prespawn phase started"
    println "[28FL] Prespawn phase started"

    // Spawn script master
    local.master = spawn ScriptMaster

    level waittill spawn
    thread logInfo "Spawn phase started - players can now join"
    println "[28FL] Spawn phase started"

    // Initialize visual effects
    thread initVisualEffects

    // Set TAB menu information
    thread setObjectiveText

    // Start game mode
    switch (level.gameMode) {
        case local.GAMEMODE_OUTBREAK:
            thread logInfo "Starting Outbreak Mode (multiple survivors)"
            println "[28FL] Starting Outbreak Mode"
            thread gameLoopOutbreak
            break
        case local.GAMEMODE_INFECTION:
            thread logInfo "Starting Infection Mode (patient zero)"
            println "[28FL] Starting Infection Mode"
            thread gameLoopInfection
            break
        case local.GAMEMODE_SURVIVAL:
            thread logInfo "Starting Survival Mode (one survivor)"
            println "[28FL] Starting Survival Mode"
            thread gameLoopSurvival
            break
        default:
            println "[28FL] ERROR: Invalid game mode: " + level.gameMode
            end
    }
end


// ============================================================================
// VISUAL EFFECTS
// ============================================================================

initVisualEffects:
    println "[28FL] Initializing visual effects"

    // Set fog/farplane settings for atmosphere
    $world farplane local.FARPLANE_DISTANCE
    $world farplane_color ( 0 0 0 )
    $world farplane_cull 1

    // Start atmospheric effects
    thread forceFastSky
    thread createStorm
end

forceFastSky:
    println "[28FL] Force fast sky rendering enabled"
    wait 2

    while (1) {
        $player stufftext "r_fastsky 1"
        wait local.UPDATE_FASTSKY
    }
end

createStorm:
    println "[28FL] Storm effects started"

    while (1) {
        wait (local.UPDATE_STORM_MIN + randomint(local.UPDATE_STORM_VAR))

        local.pattern = randomint(3) + 1

        switch (local.pattern) {
            case 1:
                // Triple flash pattern
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait 1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                $world playsound thunder
                break

            case 2:
                // Double flash with delayed thunder
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                $world playsound thunder
                wait 1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                break

            case 3:
                // Quick burst pattern
                $world farplane_color ( 0.9 0.9 0.9 )
                $world playsound thunder
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait 0.5
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                break
        }
    }
end


// ============================================================================
// UI & DISPLAY
// ============================================================================

setObjectiveText:
    setcvar "g_obj_alliedtext1" "[28 Frags Later]"

    switch (level.gameMode) {
        case 1:
            setcvar "g_obj_alliedtext2" "Outbreak Mode"
            break
        case 2:
            setcvar "g_obj_alliedtext2" "Infection Mode"
            break
        case 3:
            setcvar "g_obj_alliedtext2" "Survival Mode"
            break
    }

    setcvar "g_obj_alliedtext3" ""
    setcvar "g_obj_axistext1" ""
    setcvar "g_obj_axistext2" ""
    setcvar "g_obj_axistext3" "www.28fragslater.co.uk"
end

displayTimer local.survivor local.timeLeft:
    // Calculate minutes and seconds
    local.min = int(local.timeLeft / 60)
    local.sec = int(local.timeLeft - (local.min * 60))

    // Format time string
    local.timeStr = local.min + ":"
    if (local.sec < 10) {
        local.timeStr = local.timeStr + "0"
    }
    local.timeStr = local.timeStr + local.sec

    // Configure HUD element
    huddraw_alpha local.HUD_TIMER_ID 1
    huddraw_rect local.HUD_TIMER_ID local.HUD_TIMER_X local.HUD_TIMER_Y 640 480
    huddraw_virtualsize local.HUD_TIMER_ID 1
    huddraw_font local.HUD_TIMER_ID courier-20
    huddraw_string local.HUD_TIMER_ID local.timeStr

    // Color based on time remaining
    if (local.min == 0) {
        if (local.sec <= local.TIMER_WARNING_RED) {
            huddraw_color local.HUD_TIMER_ID 1 0 0  // Red
        } else if (local.sec <= local.TIMER_WARNING_YELLOW) {
            huddraw_color local.HUD_TIMER_ID 1 1 0  // Yellow
        } else {
            huddraw_color local.HUD_TIMER_ID 1 1 1  // White
        }
    } else {
        huddraw_color local.HUD_TIMER_ID 1 1 1  // White
    }
end

hideTimer:
    huddraw_alpha local.HUD_TIMER_ID 0
end

displayInfectionTimer:
    // Display countdown timer for infection mode
    local.lastMin = -1
    local.lastSec = -1
    
    while (level.infectionActive && level.infectionRoundStarted) {
        local.timeLeft = level.infectionRoundExpiry - level.time
        
        // Check if time expired
        if (local.timeLeft <= 0) {
            // Time's up - survivors win
            iprintlnbold_noloc "Time expired! Survivors win!"
            level.patientZero = NIL
            level.infectionActive = 0
            level.infectionRoundStarted = 0
            thread hideTimer
            wait 10
            level.infectionActive = 1
            break
        }
        
        local.min = int(local.timeLeft / 60)
        local.sec = int(local.timeLeft - (local.min * 60))
        
        // Only update display if time changed
        if (local.sec != local.lastSec || local.min != local.lastMin) {
            // Format time string
            local.timeStr = local.min + ":"
            if (local.sec < 10) {
                local.timeStr = local.timeStr + "0"
            }
            local.timeStr = local.timeStr + local.sec
            
            // Configure HUD element
            huddraw_alpha local.HUD_TIMER_ID 1
            huddraw_rect local.HUD_TIMER_ID local.HUD_TIMER_X local.HUD_TIMER_Y 640 480
            huddraw_virtualsize local.HUD_TIMER_ID 1
            huddraw_font local.HUD_TIMER_ID courier-20
            huddraw_string local.HUD_TIMER_ID local.timeStr
            
            // Color based on time remaining
            if (local.min == 0) {
                if (local.sec <= local.TIMER_WARNING_RED) {
                    huddraw_color local.HUD_TIMER_ID 1 0 0  // Red
                } else if (local.sec <= local.TIMER_WARNING_YELLOW) {
                    huddraw_color local.HUD_TIMER_ID 1 1 0  // Yellow
                } else {
                    huddraw_color local.HUD_TIMER_ID 1 1 1  // White
                }
            } else {
                huddraw_color local.HUD_TIMER_ID 1 1 1  // White
            }
            
            local.lastMin = local.min
            local.lastSec = local.sec
        }
        
        wait 0.5
    }
end


// ============================================================================
// PLAYER MANAGEMENT
// ============================================================================

playerThinker:
    // Initialize player state
    self.inGame = 0

    if (self.survivalAmount == NIL) {
        self.survivalAmount = 0
    }

    if (self.infectionAmount == NIL) {
        self.infectionAmount = 0
    }
    
    thread logVerbose "Player joined: " + self.netname

    // Create spawn trigger for this player
    local.spawnTrigger = spawn trigger_multiple origin self.origin
    local.spawnTrigger glue self
    local.spawnTrigger.player = self
    local.spawnTrigger setthread global/28fragslater.scr::onPlayerSpawn

    // Keep trigger alive while player exists
    while (self && local.spawnTrigger) {
        waitframe
    }

    // Cleanup
    thread logVerbose "Player disconnected: " + self.netname
    if (local.spawnTrigger) {
        local.spawnTrigger delete
    }
end

onPlayerSpawn:
    if (parm.other == self.player) {
        local.player = self.player
        self delete

        local.player.inGame = 1
        thread logVerbose "Player spawned: " + local.player.netname

        // Handle infection mode late joiners
        if (level.gameMode == 2 && level.infectionActive && level.infectionRoundStarted) {
            // Late joiners become infected
            thread logDebug "Late joiner " + local.player.netname + " spawning as infected"
            thread spawnAsInfected local.player
            local.player iprint "Round in progress - you are infected!"
        } else {
            // Spawn as infected by default
            thread spawnAsInfected local.player
        }
    }
end

spawnAsInfected local.player:
    thread logVerbose "Spawning " + local.player.netname + " as infected"
    local.player join_team axis
    local.player respawn
    local.player model local.MODEL_INFECTED

    waitframe

    local.player takeall
    local.player item local.WEAPON_INFECTED
    local.player useweaponclass pistol
    $player weaponcommand notdroppable
end

spawnAsSurvivor local.player:
    thread logInfo "Spawning " + local.player.netname + " as survivor (shotgun)"
    fadein 10 0 0 0 1
    waitframe

    local.player join_team allies
    local.player respawn
    local.player model local.MODEL_SURVIVOR

    waitframe

    local.player takeall
    local.player give local.WEAPON_SURVIVOR
    local.player useweaponclass heavy

    wait 5

    local.player iprint "You are the last Survivor!"
    fadein 0 0 0 0 1
end

spawnAsSurvivorWithPistol local.player:
    // Used in infection mode - survivors get pistols
    thread logInfo "Spawning " + local.player.netname + " as survivor (pistol - infection mode)"
    fadein 10 0 0 0 1
    waitframe

    local.player join_team allies
    local.player respawn
    local.player model local.MODEL_SURVIVOR

    waitframe

    local.player takeall
    local.player item local.WEAPON_INFECTED
    local.player useweaponclass pistol
    local.player weaponcommand notdroppable

    fadein 0 0 0 0 1
end

convertToInfected local.player:
    thread logInfo "Converting " + local.player.netname + " to infected (killed by infected)"
    local.player spectator
    waitframe
    local.player join_team axis
    wait 5
    local.player respawn

    waitframe

    local.player takeall
    local.player item local.WEAPON_INFECTED
    local.player useweaponclass pistol
    local.player weaponcommand notdroppable
    local.player iprint "You are infected!"
end


// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

getPlayerCount:
    local.count = 0

    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame &&
            $player[local.i].dmteam != spectator) {
            local.count++
        }
    }

    return local.count
end

getLeastSurvivorCount:
    local.least = local.MAX_SURVIVOR_COUNT

    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].survivalAmount != NIL) {
            if ($player[local.i].survivalAmount < local.least) {
                local.least = $player[local.i].survivalAmount
            }
        }
    }

    return local.least
end

selectFairestPlayer local.previousPlayer:
    local.leastCount = getLeastSurvivorCount
    local.attempts = 0
    local.maxAttempts = 100

    // Find random player with least survivor turns
    while (local.attempts < local.maxAttempts) {
        local.candidate = $player[randomint($player.size) + 1]

        // Valid if: different from previous, not spectator, has least count
        if (local.candidate != local.previousPlayer &&
            local.candidate.dmteam != spectator &&
            local.candidate.survivalAmount != NIL &&
            local.candidate.survivalAmount <= local.leastCount) {
            return local.candidate
        }

        local.attempts++
        waitframe
    }

    // Fallback: return any valid player
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i] != local.previousPlayer &&
            $player[local.i].dmteam != spectator &&
            $player[local.i].inGame) {
            return $player[local.i]
        }
    }

    return NIL
end

forcePlayerToSpawn local.player:
    while (!isAlive(local.player)) {
        local.player stufftext "+attackprimary"
        waitframe
        local.player stufftext "-attackprimary"
        waitframe
    }
end

checkProximity local.survivor:
    // Find closest infected player to survivor
    local.closestDistance = 999999
    local.closestInfected = NIL
    
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if (!$player[local.i].inGame) continue
        if ($player[local.i].dmteam != axis) continue
        
        local.distance = vector_length($player[local.i].origin - local.survivor.origin)
        
        if (local.distance < local.closestDistance) {
            local.closestDistance = local.distance
            local.closestInfected = $player[local.i]
        }
    }
    
    // If no infected players found, skip
    if (local.closestInfected == NIL) {
        end
    }
    
    // Check if within "hot" range (10m) - reset timer
    if (local.closestDistance <= local.PROXIMITY_HOT) {
        level.lastProximityTime = level.time
        
        // Clear any previous proximity indicators
        if (level.proximityTrigger == 1) {
            level.proximityTrigger = 0
        }
        end
    }
    
    // Check if we should show proximity indicators (after 1 minute timeout)
    local.timeSinceProximity = level.time - level.lastProximityTime
    
    if (local.timeSinceProximity < local.PROXIMITY_TIMEOUT) {
        // Not enough time has passed, don't show indicators
        end
    }
    
    // Show graduated proximity messages based on distance
    local.proximityMessage = ""
    
    if (local.closestDistance <= local.PROXIMITY_HOT) {
        // Already handled above - within 10m resets timer
        local.proximityMessage = "HOT"
    } else if (local.closestDistance <= local.PROXIMITY_WARM) {
        // 25m or less
        local.proximityMessage = "WARM"
    } else if (local.closestDistance <= local.PROXIMITY_COLD) {
        // 50m or less
        local.proximityMessage = "COLD"
    } else if (local.closestDistance <= local.PROXIMITY_NONE) {
        // Between 50m and 100m - no message
        local.proximityMessage = ""
    } else {
        // Beyond 100m - no message
        local.proximityMessage = ""
    }
    
    // Display message to infected players if there's something to show
    if (local.proximityMessage != "") {
        // Only show message once per second to avoid spam
        if (level.proximityTrigger == 0) {
            for (local.i = 1; local.i <= $player.size; local.i++) {
                if (!$player[local.i].inGame) continue
                if ($player[local.i].dmteam != axis) continue
                
                $player[local.i] iprintln "Proximity: " + local.proximityMessage
            }
            
            level.proximityTrigger = 1
            thread resetProximityTrigger
        }
    } else {
        // No message to show, clear trigger
        level.proximityTrigger = 0
    }
end

checkProximityAllSurvivors:
    // Find closest survivor to any infected player
    local.closestDistance = 999999
    
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if (!$player[local.i].inGame) continue
        if ($player[local.i].dmteam != allies) continue  // Only check survivors
        
        // Check distance to closest infected
        for (local.j = 1; local.j <= $player.size; local.j++) {
            if (!$player[local.j].inGame) continue
            if ($player[local.j].dmteam != axis) continue  // Only check infected
            
            local.distance = vector_length($player[local.i].origin - $player[local.j].origin)
            
            if (local.distance < local.closestDistance) {
                local.closestDistance = local.distance
            }
        }
    }
    
    // Check if within "hot" range (10m) - reset timer
    if (local.closestDistance <= local.PROXIMITY_HOT) {
        level.lastProximityTime = level.time
        
        // Clear any previous proximity indicators
        if (level.proximityTrigger == 1) {
            level.proximityTrigger = 0
        }
        end
    }
    
    // Check if we should show proximity indicators (after 1 minute timeout)
    local.timeSinceProximity = level.time - level.lastProximityTime
    
    if (local.timeSinceProximity < local.PROXIMITY_TIMEOUT) {
        // Not enough time has passed, don't show indicators
        end
    }
    
    // Show graduated proximity messages based on closest distance
    local.proximityMessage = ""
    
    if (local.closestDistance <= local.PROXIMITY_HOT) {
        // Already handled above - within 10m resets timer
        local.proximityMessage = "HOT"
    } else if (local.closestDistance <= local.PROXIMITY_WARM) {
        // 25m or less
        local.proximityMessage = "WARM"
    } else if (local.closestDistance <= local.PROXIMITY_COLD) {
        // 50m or less
        local.proximityMessage = "COLD"
    } else if (local.closestDistance <= local.PROXIMITY_NONE) {
        // Between 50m and 100m - no message
        local.proximityMessage = ""
    } else {
        // Beyond 100m - no message
        local.proximityMessage = ""
    }
    
    // Display message to infected players if there's something to show
    if (local.proximityMessage != "") {
        // Only show message once per second to avoid spam
        if (level.proximityTrigger == 0) {
            for (local.i = 1; local.i <= $player.size; local.i++) {
                if (!$player[local.i].inGame) continue
                if ($player[local.i].dmteam != axis) continue
                
                $player[local.i] iprintln "Proximity: " + local.proximityMessage
            }
            
            level.proximityTrigger = 1
            thread resetProximityTrigger
        }
    } else {
        // No message to show, clear trigger
        level.proximityTrigger = 0
    }
end

resetProximityTrigger:
    // Reset trigger after 1 second to allow next message
    wait 1
    level.proximityTrigger = 0
end

calculateSurvivalTime:
    // Count infected players
    local.infectedCount = 0
    
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && 
            $player[local.i].dmteam == axis &&
            $player[local.i].dmteam != spectator) {
            local.infectedCount++
        }
    }
    
    // Calculate time with 5% reduction per infected player
    // Formula: baseTime * (1 - (infectedCount * reductionPercent / 100))
    local.reductionFactor = local.infectedCount * local.TIME_REDUCTION_PERCENT
    local.survivalTime = local.DEFAULT_SURVIVAL_TIME * (100 - local.reductionFactor) / 100
    
    // Enforce minimum time of 1 minute
    if (local.survivalTime < local.MIN_SURVIVAL_TIME) {
        local.survivalTime = local.MIN_SURVIVAL_TIME
    }
    
    return local.survivalTime
end


// ============================================================================
// SURVIVAL MODE (Mode 3)
// ============================================================================

gameLoopSurvival:
    thread logInfo "Survival mode game loop started"
    println "[28FL] Survival mode initialized"
    wait 10

    // Main game loop
    while (1) {
        // Initialize player thinkers
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }

            // Enforce team rules
            if (isAlive($player[local.i]) &&
                $player[local.i].dmteam != spectator &&
                $player[local.i] != level.survivor &&
                $player[local.i].dmteam == allies &&
                $player[local.i].inGame) {
                thread logDebug "Enforcing team: converting " + $player[local.i].netname + " to infected"
                $player[local.i] thread convertToInfected $player[local.i]
            }

            // Clean up dead/spectating players
            if ((!isAlive($player[local.i]) || $player[local.i].dmteam == spectator) &&
                $player[local.i].inGame) {
                $player[local.i].isDone = 0
                $player[local.i].inGame = 0
            }
        }

        // Select survivor if needed
        if (level.survivor == NIL || level.survivor == NULL) {
            if (thread getPlayerCount >= local.MIN_PLAYERS) {
                thread runSurvivalRound
            }
        }

        waitframe
    }
end

runSurvivalRound:
    // Prevent concurrent selection
    if (level.selectingSurvivor) {
        end
    }

    local.playerCount = thread getPlayerCount
    if (local.playerCount < local.MIN_PLAYERS) {
        fadein 0 0 0 0 1
        end
    }

    level.selectingSurvivor = 1
    local.previousSurvivor = level.survivor

    // Select new survivor
    thread logDebug "Selecting new survivor (previous: " + local.previousSurvivor + ")"
    local.survivor = thread selectFairestPlayer local.previousSurvivor

    if (local.survivor == NIL || local.survivor == NULL) {
        level.selectingSurvivor = 0
        end
    }

    local.survivor.survivalAmount++
    level.survivor = local.survivor

    // Wait for survivor to be in game
    while (!level.survivor.inGame) {
        waitframe
    }

    level.selectingSurvivor = 0
    level.proximityTrigger = 0
    level.lastProximityTime = level.time  // Initialize proximity tracking for new round

    // Setup survivor
    thread logInfo ">>> NEW SURVIVAL ROUND STARTED <<<"
    thread logInfo "Selected survivor: " + local.survivor.netname
    println "[28FL] Selected survivor: " + local.survivor.netname
    thread spawnAsSurvivor local.survivor

    // Calculate dynamic survival time based on infected player count
    local.dynamicTime = thread calculateSurvivalTime
    level.survivorTimelimit = local.dynamicTime
    
    // Display time adjustment to all players
    local.infectedCount = 0
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && 
            $player[local.i].dmteam == axis &&
            $player[local.i].dmteam != spectator) {
            local.infectedCount++
        }
    }
    
    local.minutes = int(local.dynamicTime / 60)
    local.seconds = int(local.dynamicTime - (local.minutes * 60))
    thread logInfo "Survival time: " + local.minutes + "m " + local.seconds + "s (with " + local.infectedCount + " infected)"
    iprintlnbold_noloc "Survival time: " + local.minutes + "m " + local.seconds + "s (" + local.infectedCount + " infected)"

    // Set expiry time
    local.survivor.survivorExpiry = level.time + level.survivorTimelimit

    // Main survivor loop
    local.lastMin = -1
    local.lastSec = -1
    local.timeLimitHit = 0

    while (isAlive(local.survivor) &&
           level.survivor == local.survivor &&
           local.survivor.dmteam == allies) {

        // Update timer
        local.timeLeft = local.survivor.survivorExpiry - level.time
        local.min = int(local.timeLeft / 60)
        local.sec = int(local.timeLeft - (local.min * 60))

        if (local.sec != local.lastSec || local.min != local.lastMin) {
            thread displayTimer local.survivor local.timeLeft
            local.lastMin = local.min
            local.lastSec = local.sec
        }

        // Check proximity to infected
        thread checkProximity local.survivor

        // Check time limit
        if (level.time >= local.survivor.survivorExpiry) {
            println "[28FL] Time limit reached"
            local.timeLimitHit = 1
            break
        }

        // Force non-survivors to spawn if needed
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].inGame &&
                $player[local.i].dmteam != spectator) {
                $player[local.i] stufftext "+attackprimary"
                waitframe
                $player[local.i] stufftext "-attackprimary"
            }
        }

        waitframe
    }

    // Round ended
    thread logInfo ">>> SURVIVAL ROUND ENDED <<<"
    println "[28FL] Survivor round ended"

    // Display result
    if (local.timeLimitHit) {
        thread logInfo "Result: " + local.survivor.netname + " SURVIVED! (time expired)"
        iprintlnbold_noloc local.survivor.netname + " SURVIVED! Winner!"
        local.survivor iprint "You won! You survived the infection!"
    } else {
        thread logInfo "Result: " + local.survivor.netname + " was killed by infected"
        iprintlnbold_noloc "The Survivor has been infected!"
    }

    waitframe
    fadeout 10 0 0 0 1
    wait 5

    iprintlnbold_noloc "Selecting new survivor..."

    // Cleanup
    local.survivor.isDone = 0
    local.survivor.inGame = 0
    thread hideTimer

    // Force survivor to respawn as infected
    thread forcePlayerToSpawn local.survivor

    while (local.survivor.dmteam != axis) {
        local.survivor join_team axis
        local.survivor respawn
        waitframe
    }

    local.survivor respawn
    level.survivor = NIL
end


// ============================================================================
// OUTBREAK MODE (Mode 1)
// ============================================================================

gameLoopOutbreak:
    thread logInfo "Outbreak mode game loop started"
    println "[28FL] Outbreak mode initialized"
    println "[28FL] Multiple survivors, infection spreads on kill"

    level.outbreakActive = 1
    level.survivorCount = 3  // Start with 3 survivors

    wait 10

    while (1) {
        // Initialize players
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }
        }

        local.playerCount = thread getPlayerCount

        // Need enough players
        if (local.playerCount < 4) {
            iprintlnbold_noloc "Need at least 4 players for Outbreak mode"
            thread logDebug "Waiting for players (need 4, have " + local.playerCount + ")"
            wait 5
            waitframe
            continue
        }

        // Select initial survivors
        if (level.outbreakSurvivors == NIL) {
            thread selectOutbreakSurvivors
            level.lastProximityTime = level.time  // Initialize proximity tracking
        }
        
        // Check proximity if survivors are active
        if (level.outbreakSurvivors != NIL) {
            thread checkProximityAllSurvivors
        }

        waitframe
    }
end

selectOutbreakSurvivors:
    thread logInfo ">>> NEW OUTBREAK ROUND STARTED <<<"
    thread logInfo "Selecting " + level.survivorCount + " survivors for Outbreak"
    println "[28FL] Selecting " + level.survivorCount + " survivors for Outbreak"

    level.outbreakSurvivors = []
    local.selected = 0

    // Randomly select survivors
    while (local.selected < level.survivorCount) {
        local.candidate = $player[randomint($player.size) + 1]

        if (local.candidate.inGame &&
            local.candidate.dmteam != spectator &&
            !isInArray(level.outbreakSurvivors, local.candidate)) {

            level.outbreakSurvivors[local.selected] = local.candidate
            thread spawnAsSurvivor local.candidate
            thread logInfo "Selected survivor " + (local.selected + 1) + ": " + local.candidate.netname
            local.candidate iprint "You are a survivor! Work together!"

            local.selected++
        }

        waitframe
    }

    iprintlnbold_noloc level.survivorCount + " survivors selected. Infected must eliminate them all!"
end


// ============================================================================
// INFECTION MODE (Mode 2)
// ============================================================================

gameLoopInfection:
    thread logInfo "Infection mode game loop started"
    println "[28FL] Infection mode initialized"
    println "[28FL] First infected must infect all survivors"

    level.infectionActive = 1
    level.infectionRoundStarted = 0

    wait 10

    while (1) {
        // Initialize players
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }
            
            // Initialize infection marker
            if ($player[local.i].needsInfection == NIL) {
                $player[local.i].needsInfection = 0
            }
        }

        local.playerCount = thread getPlayerCount

        if (local.playerCount < local.MIN_PLAYERS) {
            wait 5
            waitframe
            continue
        }

        // Select patient zero if needed
        if (level.patientZero == NIL) {
            thread selectPatientZero
            
            // Start round with timer
            level.infectionRoundStarted = 1
            level.infectionRoundExpiry = level.time + local.INFECTION_TIME_LIMIT
            level.lastProximityTime = level.time  // Initialize proximity tracking
            
            // Display round start message
            iprintlnbold_noloc "Infection round started! 5 minutes to survive!"
            
            // Start death monitoring
            thread monitorInfectionDeaths
            
            // Start timer display
            thread displayInfectionTimer
        }

        // Monitor infection spread
        thread monitorInfection
        
        // Check proximity if round is active
        if (level.infectionRoundStarted) {
            thread checkProximityAllSurvivors
        }

        waitframe
    }
end

selectPatientZero:
    thread logInfo ">>> NEW INFECTION ROUND STARTED <<<"
    thread logInfo "Selecting Patient Zero"
    println "[28FL] Selecting Patient Zero"

    local.infected = thread selectFairestPlayer NIL

    if (local.infected == NIL) {
        end
    }

    level.patientZero = local.infected
    local.infected.infectionAmount++
    thread logInfo "Patient Zero: " + local.infected.netname

    // Make everyone survivors except patient zero - all get pistols
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && $player[local.i].dmteam != spectator) {
            if ($player[local.i] == local.infected) {
                thread spawnAsInfected $player[local.i]
                $player[local.i] iprint "You are Patient Zero! Infect everyone!"
            } else {
                thread spawnAsSurvivorWithPistol $player[local.i]
                $player[local.i] iprint "You are a survivor! Avoid infection!"
            }
        }
    }

    iprintlnbold_noloc local.infected.netname + " is Patient Zero!"
end

monitorInfection:
    while (level.infectionActive) {
        // Check if all survivors are infected
        local.survivorCount = 0
        local.infectedCount = 0

        for (local.i = 1; local.i <= $player.size; local.i++) {
            if ($player[local.i].inGame && isAlive($player[local.i])) {
                if ($player[local.i].dmteam == allies) {
                    local.survivorCount++
                } else if ($player[local.i].dmteam == axis) {
                    local.infectedCount++
                }
            }
        }

        // Check win conditions
        if (local.survivorCount == 0 && local.infectedCount > 0) {
            thread logInfo ">>> INFECTION ROUND ENDED <<<"
            thread logInfo "Result: All survivors infected"
            iprintlnbold_noloc "All survivors have been infected!"
            level.patientZero = NIL
            level.infectionActive = 0
            level.infectionRoundStarted = 0
            wait 10
            level.infectionActive = 1
            break
        }

        wait 1
    }
end

monitorInfectionDeaths:
    // Monitor for survivor deaths and convert them to infected
    while (level.infectionActive && level.infectionRoundStarted) {
        for (local.i = 1; local.i <= $player.size; local.i++) {
            // Check if survivor died and needs conversion
            if ($player[local.i].inGame && 
                !isAlive($player[local.i]) && 
                $player[local.i].dmteam == allies &&
                $player[local.i] != level.patientZero) {
                
                // Mark player for conversion on next spawn
                $player[local.i].needsInfection = 1
            }
            
            // Convert respawned survivors to infected
            if ($player[local.i].inGame && 
                isAlive($player[local.i]) &&
                $player[local.i].dmteam == allies &&
                $player[local.i].needsInfection == 1 &&
                $player[local.i] != level.patientZero) {
                
                $player[local.i].needsInfection = 0
                thread convertToInfected $player[local.i]
                $player[local.i] iprint "You have been infected!"
            }
        }
        
        waitframe
    }
end


// ============================================================================
// END OF SCRIPT
// ============================================================================
