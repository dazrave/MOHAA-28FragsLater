// ============================================================================
// 28 Frags Later Mod - REFACTORED VERSION
// ============================================================================
// Original Author: Ophis
// Refactored: 2025
// Contact: ophis@daphi.co.uk
// Special thanks: Falco
//
// A zombie/infection survival mod for Medal of Honor: Allied Assault
// Transforms Team Deathmatch into an asymmetric horror experience
// ============================================================================

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

// Game mode constants
local.GAMEMODE_OFF = 0
local.GAMEMODE_OUTBREAK = 1      // Multiple survivors, infection spreads
local.GAMEMODE_INFECTION = 2     // Classic infection - one infected infects others
local.GAMEMODE_SURVIVAL = 3      // One survivor vs all infected

// Script configuration
local.SCRIPT_VERSION = "1.0.0"
local.REQUIRED_GAMETYPE = 2      // Team Deathmatch

// Gameplay constants
local.SURVIVOR_TIME_LIMIT = 200  // Seconds survivor has to survive (LEGACY - not used with dynamic timing)
local.MIN_PLAYERS = 2            // Minimum players to start game
local.PROXIMITY_DISTANCE = 500   // Distance for proximity alerts
local.TIMER_WARNING_YELLOW = 30  // Yellow warning at 30 seconds
local.TIMER_WARNING_RED = 10     // Red warning at 10 seconds

// Dynamic Survival Time (Option 3 Scoring System)
local.DEFAULT_SURVIVAL_TIME = 300     // Default 5 minutes
local.TIME_REDUCTION_PERCENT = 5      // 5% reduction per infected player
local.MIN_SURVIVAL_TIME = 60          // Minimum 1 minute

// Team constants
local.TEAM_INFECTED = "axis"
local.TEAM_SURVIVOR = "allies"

// Model paths
local.MODEL_INFECTED = "models/player/german_[Kapo]_Prisioner_1.tik"
local.MODEL_SURVIVOR = "models/player/allied_Magna_Cartas_police.tik"

// Weapon paths
local.WEAPON_INFECTED = "models/weapons/colt45.tik"
local.WEAPON_SURVIVOR = "models/weapons/shotgun.tik"

// HUD constants
local.HUD_TIMER_ID = 107
local.HUD_TIMER_X = 500
local.HUD_TIMER_Y = 35

// Visual effects
local.FARPLANE_DISTANCE = 1600
local.FARPLANE_COLOR_NORMAL = "0 0 0"
local.FARPLANE_COLOR_LIGHTNING = "0.9 0.9 0.9"

// Update intervals (in seconds)
local.UPDATE_FASTSKY = 10
local.UPDATE_STORM_MIN = 30
local.UPDATE_STORM_VAR = 15

// Survivor selection constants
local.MAX_SURVIVOR_COUNT = 524288  // Maximum times someone can be survivor


// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

main:
    // Validate game mode
    if (int(getcvar(28FragsLater)) == local.GAMEMODE_OFF) {
        end
    }

    local.gameMode = int(getcvar(28FragsLater))
    println "[28FL] Starting 28 Frags Later Mod v" + local.SCRIPT_VERSION
    println "[28FL] Game Mode: " + local.gameMode

    // Prevent duplicate script execution
    if (level.isRunning) {
        println "[28FL] ERROR: Script already running. Terminating."
        end
    }
    level.isRunning = 1

    // Validate Team Deathmatch is active
    if (int(getcvar(g_gametype)) != local.REQUIRED_GAMETYPE) {
        println "[28FL] ERROR: Requires Team Deathmatch (g_gametype 2). Terminating."
        end
    }

    // Initialize level variables
    level.scriptVersion = local.SCRIPT_VERSION
    level.gameMode = local.gameMode
    level.survivorTimelimit = local.DEFAULT_SURVIVAL_TIME
    level.proximityTrigger = 0
    level.selectingSurvivor = 0
    level.survivor = NIL

    println "[28FL] Default survival time: " + level.survivorTimelimit + " seconds"

    // Set game type display name
    setcvar "g_gametypestring" "28 Frags Later"

    // Wait for game initialization
    level waittill prespawn
    println "[28FL] Prespawn phase started"

    // Spawn script master
    local.master = spawn ScriptMaster

    level waittill spawn
    println "[28FL] Spawn phase started"

    // Initialize visual effects
    thread initVisualEffects

    // Set TAB menu information
    thread setObjectiveText

    // Start game mode
    switch (level.gameMode) {
        case local.GAMEMODE_OUTBREAK:
            println "[28FL] Starting Outbreak Mode"
            thread gameLoopOutbreak
            break
        case local.GAMEMODE_INFECTION:
            println "[28FL] Starting Infection Mode"
            thread gameLoopInfection
            break
        case local.GAMEMODE_SURVIVAL:
            println "[28FL] Starting Survival Mode"
            thread gameLoopSurvival
            break
        default:
            println "[28FL] ERROR: Invalid game mode: " + level.gameMode
            end
    }
end


// ============================================================================
// VISUAL EFFECTS
// ============================================================================

initVisualEffects:
    println "[28FL] Initializing visual effects"

    // Set fog/farplane settings for atmosphere
    $world farplane local.FARPLANE_DISTANCE
    $world farplane_color ( 0 0 0 )
    $world farplane_cull 1

    // Start atmospheric effects
    thread forceFastSky
    thread createStorm
end

forceFastSky:
    println "[28FL] Force fast sky rendering enabled"
    wait 2

    while (1) {
        $player stufftext "r_fastsky 1"
        wait local.UPDATE_FASTSKY
    }
end

createStorm:
    println "[28FL] Storm effects started"

    while (1) {
        wait (local.UPDATE_STORM_MIN + randomint(local.UPDATE_STORM_VAR))

        local.pattern = randomint(3) + 1

        switch (local.pattern) {
            case 1:
                // Triple flash pattern
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait 1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                $world playsound thunder
                break

            case 2:
                // Double flash with delayed thunder
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                $world playsound thunder
                wait 1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                break

            case 3:
                // Quick burst pattern
                $world farplane_color ( 0.9 0.9 0.9 )
                $world playsound thunder
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait 0.1
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.2
                $world farplane_color ( 0 0 0 )
                wait 0.5
                $world farplane_color ( 0.9 0.9 0.9 )
                wait 0.1
                $world farplane_color ( 0 0 0 )
                wait (1 + randomfloat(2))
                break
        }
    }
end


// ============================================================================
// UI & DISPLAY
// ============================================================================

setObjectiveText:
    setcvar "g_obj_alliedtext1" "[28 Frags Later]"

    switch (level.gameMode) {
        case 1:
            setcvar "g_obj_alliedtext2" "Outbreak Mode"
            break
        case 2:
            setcvar "g_obj_alliedtext2" "Infection Mode"
            break
        case 3:
            setcvar "g_obj_alliedtext2" "Survival Mode"
            break
    }

    setcvar "g_obj_alliedtext3" ""
    setcvar "g_obj_axistext1" ""
    setcvar "g_obj_axistext2" ""
    setcvar "g_obj_axistext3" "www.28fragslater.co.uk"
end

displayTimer local.survivor local.timeLeft:
    // Calculate minutes and seconds
    local.min = int(local.timeLeft / 60)
    local.sec = int(local.timeLeft - (local.min * 60))

    // Format time string
    local.timeStr = local.min + ":"
    if (local.sec < 10) {
        local.timeStr = local.timeStr + "0"
    }
    local.timeStr = local.timeStr + local.sec

    // Configure HUD element
    huddraw_alpha local.HUD_TIMER_ID 1
    huddraw_rect local.HUD_TIMER_ID local.HUD_TIMER_X local.HUD_TIMER_Y 640 480
    huddraw_virtualsize local.HUD_TIMER_ID 1
    huddraw_font local.HUD_TIMER_ID courier-20
    huddraw_string local.HUD_TIMER_ID local.timeStr

    // Color based on time remaining
    if (local.min == 0) {
        if (local.sec <= local.TIMER_WARNING_RED) {
            huddraw_color local.HUD_TIMER_ID 1 0 0  // Red
        } else if (local.sec <= local.TIMER_WARNING_YELLOW) {
            huddraw_color local.HUD_TIMER_ID 1 1 0  // Yellow
        } else {
            huddraw_color local.HUD_TIMER_ID 1 1 1  // White
        }
    } else {
        huddraw_color local.HUD_TIMER_ID 1 1 1  // White
    }
end

hideTimer:
    huddraw_alpha local.HUD_TIMER_ID 0
end


// ============================================================================
// PLAYER MANAGEMENT
// ============================================================================

playerThinker:
    // Initialize player state
    self.inGame = 0

    if (self.survivalAmount == NIL) {
        self.survivalAmount = 0
    }

    if (self.infectionAmount == NIL) {
        self.infectionAmount = 0
    }

    // Create spawn trigger for this player
    local.spawnTrigger = spawn trigger_multiple origin self.origin
    local.spawnTrigger glue self
    local.spawnTrigger.player = self
    local.spawnTrigger setthread global/28fragslater.scr::onPlayerSpawn

    // Keep trigger alive while player exists
    while (self && local.spawnTrigger) {
        waitframe
    }

    // Cleanup
    if (local.spawnTrigger) {
        local.spawnTrigger delete
    }
end

onPlayerSpawn:
    if (parm.other == self.player) {
        local.player = self.player
        self delete

        local.player.inGame = 1

        // Spawn as infected by default
        thread spawnAsInfected local.player
    }
end

spawnAsInfected local.player:
    local.player join_team axis
    local.player respawn
    local.player model local.MODEL_INFECTED

    waitframe

    local.player takeall
    local.player item local.WEAPON_INFECTED
    local.player useweaponclass pistol
    $player weaponcommand notdroppable
end

spawnAsSurvivor local.player:
    fadein 10 0 0 0 1
    waitframe

    local.player join_team allies
    local.player respawn
    local.player model local.MODEL_SURVIVOR

    waitframe

    local.player takeall
    local.player give local.WEAPON_SURVIVOR
    local.player useweaponclass heavy

    wait 5

    local.player iprint "You are the last Survivor!"
    fadein 0 0 0 0 1
end

convertToInfected local.player:
    local.player spectator
    waitframe
    local.player join_team axis
    wait 5
    local.player respawn

    waitframe

    local.player takeall
    local.player item local.WEAPON_INFECTED
    local.player useweaponclass pistol
    local.player weaponcommand notdroppable
    local.player iprint "You are infected!"
end


// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

getPlayerCount:
    local.count = 0

    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame &&
            $player[local.i].dmteam != spectator) {
            local.count++
        }
    }

    return local.count
end

getLeastSurvivorCount:
    local.least = local.MAX_SURVIVOR_COUNT

    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].survivalAmount != NIL) {
            if ($player[local.i].survivalAmount < local.least) {
                local.least = $player[local.i].survivalAmount
            }
        }
    }

    return local.least
end

selectFairestPlayer local.previousPlayer:
    local.leastCount = getLeastSurvivorCount
    local.attempts = 0
    local.maxAttempts = 100

    // Find random player with least survivor turns
    while (local.attempts < local.maxAttempts) {
        local.candidate = $player[randomint($player.size) + 1]

        // Valid if: different from previous, not spectator, has least count
        if (local.candidate != local.previousPlayer &&
            local.candidate.dmteam != spectator &&
            local.candidate.survivalAmount != NIL &&
            local.candidate.survivalAmount <= local.leastCount) {
            return local.candidate
        }

        local.attempts++
        waitframe
    }

    // Fallback: return any valid player
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i] != local.previousPlayer &&
            $player[local.i].dmteam != spectator &&
            $player[local.i].inGame) {
            return $player[local.i]
        }
    }

    return NIL
end

forcePlayerToSpawn local.player:
    while (!isAlive(local.player)) {
        local.player stufftext "+attackprimary"
        waitframe
        local.player stufftext "-attackprimary"
        waitframe
    }
end

checkProximity local.survivor:
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if (!$player[local.i].inGame) continue
        if ($player[local.i].dmteam != axis) continue

        local.distance = vector_length($player[local.i].origin - local.survivor.origin)

        if (local.distance <= local.PROXIMITY_DISTANCE && level.proximityTrigger == 0) {
            $player[local.i] stufftext "sayteam I'm close to the survivor!"
            local.survivor stufftext "sayteam I hear them, they are getting closer!"
            level.proximityTrigger = 1
        }

        if (local.distance > local.PROXIMITY_DISTANCE && level.proximityTrigger == 1) {
            level.proximityTrigger = 0
        }
    }
end

calculateSurvivalTime:
    // Count infected players
    local.infectedCount = 0
    
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && 
            $player[local.i].dmteam == axis &&
            $player[local.i].dmteam != spectator) {
            local.infectedCount++
        }
    }
    
    // Calculate time with 5% reduction per infected player
    // Formula: baseTime * (1 - (infectedCount * reductionPercent / 100))
    local.reductionFactor = local.infectedCount * local.TIME_REDUCTION_PERCENT
    local.survivalTime = local.DEFAULT_SURVIVAL_TIME * (100 - local.reductionFactor) / 100
    
    // Enforce minimum time of 1 minute
    if (local.survivalTime < local.MIN_SURVIVAL_TIME) {
        local.survivalTime = local.MIN_SURVIVAL_TIME
    }
    
    return local.survivalTime
end


// ============================================================================
// SURVIVAL MODE (Mode 3)
// ============================================================================

gameLoopSurvival:
    println "[28FL] Survival mode initialized"
    wait 10

    // Main game loop
    while (1) {
        // Initialize player thinkers
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }

            // Enforce team rules
            if (isAlive($player[local.i]) &&
                $player[local.i].dmteam != spectator &&
                $player[local.i] != level.survivor &&
                $player[local.i].dmteam == allies &&
                $player[local.i].inGame) {
                $player[local.i] thread convertToInfected $player[local.i]
            }

            // Clean up dead/spectating players
            if ((!isAlive($player[local.i]) || $player[local.i].dmteam == spectator) &&
                $player[local.i].inGame) {
                $player[local.i].isDone = 0
                $player[local.i].inGame = 0
            }
        }

        // Select survivor if needed
        if (level.survivor == NIL || level.survivor == NULL) {
            if (thread getPlayerCount >= local.MIN_PLAYERS) {
                thread runSurvivalRound
            }
        }

        waitframe
    }
end

runSurvivalRound:
    // Prevent concurrent selection
    if (level.selectingSurvivor) {
        end
    }

    local.playerCount = thread getPlayerCount
    if (local.playerCount < local.MIN_PLAYERS) {
        fadein 0 0 0 0 1
        end
    }

    level.selectingSurvivor = 1
    local.previousSurvivor = level.survivor

    // Select new survivor
    local.survivor = thread selectFairestPlayer local.previousSurvivor

    if (local.survivor == NIL || local.survivor == NULL) {
        level.selectingSurvivor = 0
        end
    }

    local.survivor.survivalAmount++
    level.survivor = local.survivor

    // Wait for survivor to be in game
    while (!level.survivor.inGame) {
        waitframe
    }

    level.selectingSurvivor = 0
    level.proximityTrigger = 0

    // Setup survivor
    println "[28FL] Selected survivor: " + local.survivor.netname
    thread spawnAsSurvivor local.survivor

    // Calculate dynamic survival time based on infected player count
    local.dynamicTime = thread calculateSurvivalTime
    level.survivorTimelimit = local.dynamicTime
    
    // Display time adjustment to all players
    local.infectedCount = 0
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && 
            $player[local.i].dmteam == axis &&
            $player[local.i].dmteam != spectator) {
            local.infectedCount++
        }
    }
    
    local.minutes = int(local.dynamicTime / 60)
    local.seconds = int(local.dynamicTime - (local.minutes * 60))
    iprintlnbold_noloc "Survival time: " + local.minutes + "m " + local.seconds + "s (" + local.infectedCount + " infected)"

    // Set expiry time
    local.survivor.survivorExpiry = level.time + level.survivorTimelimit

    // Main survivor loop
    local.lastMin = -1
    local.lastSec = -1
    local.timeLimitHit = 0

    while (isAlive(local.survivor) &&
           level.survivor == local.survivor &&
           local.survivor.dmteam == allies) {

        // Update timer
        local.timeLeft = local.survivor.survivorExpiry - level.time
        local.min = int(local.timeLeft / 60)
        local.sec = int(local.timeLeft - (local.min * 60))

        if (local.sec != local.lastSec || local.min != local.lastMin) {
            thread displayTimer local.survivor local.timeLeft
            local.lastMin = local.min
            local.lastSec = local.sec
        }

        // Check proximity to infected
        thread checkProximity local.survivor

        // Check time limit
        if (level.time >= local.survivor.survivorExpiry) {
            println "[28FL] Time limit reached"
            local.timeLimitHit = 1
            break
        }

        // Force non-survivors to spawn if needed
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].inGame &&
                $player[local.i].dmteam != spectator) {
                $player[local.i] stufftext "+attackprimary"
                waitframe
                $player[local.i] stufftext "-attackprimary"
            }
        }

        waitframe
    }

    // Round ended
    println "[28FL] Survivor round ended"

    // Display result
    if (local.timeLimitHit) {
        iprintlnbold_noloc local.survivor.netname + " SURVIVED! Winner!"
        local.survivor iprint "You won! You survived the infection!"
    } else {
        iprintlnbold_noloc "The Survivor has been infected!"
    }

    waitframe
    fadeout 10 0 0 0 1
    wait 5

    iprintlnbold_noloc "Selecting new survivor..."

    // Cleanup
    local.survivor.isDone = 0
    local.survivor.inGame = 0
    thread hideTimer

    // Force survivor to respawn as infected
    thread forcePlayerToSpawn local.survivor

    while (local.survivor.dmteam != axis) {
        local.survivor join_team axis
        local.survivor respawn
        waitframe
    }

    local.survivor respawn
    level.survivor = NIL
end


// ============================================================================
// OUTBREAK MODE (Mode 1)
// ============================================================================

gameLoopOutbreak:
    println "[28FL] Outbreak mode initialized"
    println "[28FL] Multiple survivors, infection spreads on kill"

    level.outbreakActive = 1
    level.survivorCount = 3  // Start with 3 survivors

    wait 10

    while (1) {
        // Initialize players
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }
        }

        local.playerCount = thread getPlayerCount

        // Need enough players
        if (local.playerCount < 4) {
            iprintlnbold_noloc "Need at least 4 players for Outbreak mode"
            wait 5
            waitframe
            continue
        }

        // Select initial survivors
        if (level.outbreakSurvivors == NIL) {
            thread selectOutbreakSurvivors
        }

        waitframe
    }
end

selectOutbreakSurvivors:
    println "[28FL] Selecting " + level.survivorCount + " survivors for Outbreak"

    level.outbreakSurvivors = []
    local.selected = 0

    // Randomly select survivors
    while (local.selected < level.survivorCount) {
        local.candidate = $player[randomint($player.size) + 1]

        if (local.candidate.inGame &&
            local.candidate.dmteam != spectator &&
            !isInArray(level.outbreakSurvivors, local.candidate)) {

            level.outbreakSurvivors[local.selected] = local.candidate
            thread spawnAsSurvivor local.candidate
            local.candidate iprint "You are a survivor! Work together!"

            local.selected++
        }

        waitframe
    }

    iprintlnbold_noloc level.survivorCount + " survivors selected. Infected must eliminate them all!"
end


// ============================================================================
// INFECTION MODE (Mode 2)
// ============================================================================

gameLoopInfection:
    println "[28FL] Infection mode initialized"
    println "[28FL] First infected must infect all survivors"

    level.infectionActive = 1

    wait 10

    while (1) {
        // Initialize players
        for (local.i = 1; local.i <= $player.size; local.i++) {
            if (!$player[local.i].isDone) {
                $player[local.i].isDone = 1
                $player[local.i] thread playerThinker
            }
        }

        local.playerCount = thread getPlayerCount

        if (local.playerCount < local.MIN_PLAYERS) {
            wait 5
            waitframe
            continue
        }

        // Select patient zero if needed
        if (level.patientZero == NIL) {
            thread selectPatientZero
        }

        // Monitor infection spread
        thread monitorInfection

        waitframe
    }
end

selectPatientZero:
    println "[28FL] Selecting Patient Zero"

    local.infected = thread selectFairestPlayer NIL

    if (local.infected == NIL) {
        end
    }

    level.patientZero = local.infected
    local.infected.infectionAmount++

    // Make everyone survivors except patient zero
    for (local.i = 1; local.i <= $player.size; local.i++) {
        if ($player[local.i].inGame && $player[local.i].dmteam != spectator) {
            if ($player[local.i] == local.infected) {
                thread spawnAsInfected $player[local.i]
                $player[local.i] iprint "You are Patient Zero! Infect everyone!"
            } else {
                thread spawnAsSurvivor $player[local.i]
                $player[local.i] iprint "You are a survivor! Avoid infection!"
            }
        }
    }

    iprintlnbold_noloc local.infected.netname + " is Patient Zero!"
end

monitorInfection:
    while (level.infectionActive) {
        // Check if all survivors are infected
        local.survivorCount = 0
        local.infectedCount = 0

        for (local.i = 1; local.i <= $player.size; local.i++) {
            if ($player[local.i].inGame && isAlive($player[local.i])) {
                if ($player[local.i].dmteam == allies) {
                    local.survivorCount++
                } else if ($player[local.i].dmteam == axis) {
                    local.infectedCount++
                }
            }
        }

        // Check win conditions
        if (local.survivorCount == 0 && local.infectedCount > 0) {
            iprintlnbold_noloc "All survivors have been infected!"
            level.patientZero = NIL
            level.infectionActive = 0
            wait 10
            level.infectionActive = 1
            break
        }

        wait 1
    }
end


// ============================================================================
// END OF SCRIPT
// ============================================================================
